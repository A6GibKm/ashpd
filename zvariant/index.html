<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `zvariant` crate."><meta name="keywords" content="rust, rustlang, rust-lang, zvariant"><title>zvariant - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../zvariant/index.html'><div class='logo-container'><img src='https://storage.googleapis.com/fdo-gitlab-uploads/project/avatar/3213/zbus-logomark.png' alt='logo'></div></a><p class='location'>Crate zvariant</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all zvariant's items</p></a><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'zvariant', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/zvariant/lib.rs.html#1-962' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>zvariant</a></span></h1><div class='docblock'><p>This crate provides API for serialization/deserialization of data to/from <a href="https://dbus.freedesktop.org/doc/dbus-specification.html">D-Bus</a> wire format.
This binary wire format is simple and very efficient and hence useful outside of D-Bus context
as well. A slightly modified form of this format, <a href="https://developer.gnome.org/glib/stable/glib-GVariant.html">GVariant</a> is also very common and will be
supported by a future version of this crate.</p>
<p>Since version 2.0, the API is <a href="https://crates.io/crates/serde">serde</a>-based and hence you'll find it very intuitive if you're
already familiar with serde. If you're not familiar with serde, you may want to first read its
<a href="https://serde.rs/">tutorial</a> before learning further about this crate.</p>
<p>Serialization and deserialization is achieved through the <a href="#functions">toplevel functions</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">use</span> <span class="ident">byteorder</span>::<span class="ident">LE</span>;
<span class="kw">use</span> <span class="ident">zvariant</span>::{<span class="ident">from_slice</span>, <span class="ident">to_bytes</span>};
<span class="kw">use</span> <span class="ident">zvariant</span>::<span class="ident">EncodingContext</span> <span class="kw">as</span> <span class="ident">Context</span>;

<span class="comment">// All serialization and deserialization API, needs a context.</span>
<span class="kw">let</span> <span class="ident">ctxt</span> <span class="op">=</span> <span class="ident">Context</span>::<span class="op">&lt;</span><span class="ident">LE</span><span class="op">&gt;</span>::<span class="ident">new_dbus</span>(<span class="number">0</span>);

<span class="comment">// i16</span>
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="ident">ctxt</span>, <span class="kw-2">&amp;</span><span class="number">42i16</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decoded</span>: <span class="ident">i16</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">ctxt</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>, <span class="number">42</span>);

<span class="comment">// strings</span>
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="ident">ctxt</span>, <span class="kw-2">&amp;</span><span class="string">&quot;hello&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decoded</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">ctxt</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>, <span class="string">&quot;hello&quot;</span>);

<span class="comment">// tuples</span>
<span class="kw">let</span> <span class="ident">t</span> <span class="op">=</span> (<span class="string">&quot;hello&quot;</span>, <span class="number">42i32</span>, <span class="bool-val">true</span>);
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="ident">ctxt</span>, <span class="kw-2">&amp;</span><span class="ident">t</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decoded</span>: (<span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">i32</span>, <span class="ident">bool</span>) <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">ctxt</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>, <span class="ident">t</span>);

<span class="comment">// Vec</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>];
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="ident">ctxt</span>, <span class="kw-2">&amp;</span><span class="ident">v</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decoded</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">ctxt</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>, <span class="ident">v</span>);

<span class="comment">// Dictionary</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">i64</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">&quot;456&quot;</span>);
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_bytes</span>(<span class="ident">ctxt</span>, <span class="kw-2">&amp;</span><span class="ident">map</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decoded</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">i64</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">encoded</span>, <span class="ident">ctxt</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>[<span class="kw-2">&amp;</span><span class="number">1</span>], <span class="string">&quot;123&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decoded</span>[<span class="kw-2">&amp;</span><span class="number">2</span>], <span class="string">&quot;456&quot;</span>);</pre></div>
<p>Apart from the obvious requirement of <a href="struct.EncodingContext.html"><code>EncodingContext</code></a> instance by the main serialization and
deserialization API, the type being serialized or deserialized must also implement <code>Type</code>
trait in addition to <a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> or <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a>, respectively. Please refer to <a href="trait.Type.html"><code>Type</code>
module documentation</a> for more details.</p>
<p>Most of the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#basic-types">basic types</a> of D-Bus match 1-1 wit all the primitive Rust types. The only two
exceptions being, <a href="struct.Signature.html"><code>Signature</code></a> and <a href="struct.ObjectPath.html"><code>ObjectPath</code></a>, which are really just strings. These types
are covered by the <a href="trait.Basic.html"><code>Basic</code></a> trait.</p>
<p>Similarly, most of the <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#container-types">container types</a> also map nicely to the usual Rust types and
collections (as can be seen in the example code above). The only note worthy exception being
ARRAY type. As arrays in Rust are fixed-sized, serde treats them as tuples and so does this
crate. This means they are encoded as STRUCT type of D-Bus. If you need to serialize to, or
deserialize from a D-Bus array, you'll need to use a <a href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a> (array can easily be converted to a
slice), a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> or an <a href="https://docs.rs/arrayvec/0.5.1/arrayvec/struct.ArrayVec.html"><code>arrayvec::ArrayVec</code></a>.</p>
<p>The generic D-Bus type, <code>VARIANT</code> is represented by <code>Value</code>, an enum that holds exactly one
value of any of the other types. Please refer to <a href="enum.Value.html"><code>Value</code> module documentation</a> for examples.</p>
<h1 id="no-std" class="section-header"><a href="#no-std">no-std</a></h1>
<p>While <code>std</code> is currently a hard requirement, optional <code>no-std</code> support is planned in the future.
On the other hand, <code>noalloc</code> support is not planned as it will be an extremely difficult to
accomplish, if at all possible.</p>
<h1 id="optional-features" class="section-header"><a href="#optional-features">Optional features</a></h1><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>arrayvec</td><td>Implement <code>Type</code> for <a href="https://docs.rs/arrayvec/0.5.1/arrayvec/struct.ArrayVec.html"><code>arrayvec::ArrayVec</code></a> and <a href="https://docs.rs/arrayvec/0.5.1/arrayvec/struct.ArrayString.html"><code>arrayvec::ArrayString</code></a></td></tr>
<tr><td>enumflags2</td><td>Implement <code>Type</code> for [<code>enumflags2::BitFlags&lt;F&gt;</code>]</td></tr>
</tbody></table>
<h1 id="portability" class="section-header"><a href="#portability">Portability</a></h1>
<p>zvariant is currently Unix-only and will fail to build on non-unix. This is hopefully a
temporary limitation.</p>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.alias_type.html" title='zvariant::alias_type macro'>alias_type</a></td><td class='docblock-short'></td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Array.html" title='zvariant::Array struct'>Array</a></td><td class='docblock-short'><p>A helper type to wrap arrays in a <a href="enum.Value.html#variant.Array"><code>Value</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DeserializeValue.html" title='zvariant::DeserializeValue struct'>DeserializeValue</a></td><td class='docblock-short'><p>A wrapper to deserialize a value to <code>T: Type + Deserialize</code>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Deserializer.html" title='zvariant::Deserializer struct'>Deserializer</a></td><td class='docblock-short'><p>Our deserialization implementation.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Dict.html" title='zvariant::Dict struct'>Dict</a></td><td class='docblock-short'><p>A helper type to wrap dictionaries in a <a href="enum.Value.html#variant.Dict"><code>Value</code></a>.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.EncodingContext.html" title='zvariant::EncodingContext struct'>EncodingContext</a></td><td class='docblock-short'><p>The encoding context to use with the <a href="index.html#functions">serialization and deserialization</a> API.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Fd.html" title='zvariant::Fd struct'>Fd</a></td><td class='docblock-short'><p>A <a href="https://doc.rust-lang.org/std/os/unix/io/type.RawFd.html"><code>RawFd</code></a> wrapper.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ObjectPath.html" title='zvariant::ObjectPath struct'>ObjectPath</a></td><td class='docblock-short'><p>String that identifies objects at a given destination on the D-Bus bus.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.OwnedObjectPath.html" title='zvariant::OwnedObjectPath struct'>OwnedObjectPath</a></td><td class='docblock-short'><p>Owned <a href="struct.ObjectPath.html"><code>ObjectPath</code></a></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.OwnedSignature.html" title='zvariant::OwnedSignature struct'>OwnedSignature</a></td><td class='docblock-short'><p>Owned <a href="struct.Signature.html"><code>Signature</code></a></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.OwnedValue.html" title='zvariant::OwnedValue struct'>OwnedValue</a></td><td class='docblock-short'><p>Owned <a href="enum.Value.html"><code>Value</code></a></p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SerializeValue.html" title='zvariant::SerializeValue struct'>SerializeValue</a></td><td class='docblock-short'><p>A wrapper to serialize <code>T: Type + Serialize</code> as a value.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Serializer.html" title='zvariant::Serializer struct'>Serializer</a></td><td class='docblock-short'><p>Our serialization implementation.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Signature.html" title='zvariant::Signature struct'>Signature</a></td><td class='docblock-short'><p>String that <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#type-system">identifies</a> the type of an encoded value.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Str.html" title='zvariant::Str struct'>Str</a></td><td class='docblock-short'><p>A string wrapper.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Structure.html" title='zvariant::Structure struct'>Structure</a></td><td class='docblock-short'><p>A helper type to wrap structs in <a href="enum.Value.html"><code>Value</code></a>.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.EncodingFormat.html" title='zvariant::EncodingFormat enum'>EncodingFormat</a></td><td class='docblock-short'><p>The encoding format.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Error.html" title='zvariant::Error enum'>Error</a></td><td class='docblock-short'><p>Error type used by zvariant API.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Value.html" title='zvariant::Value enum'>Value</a></td><td class='docblock-short'><p>A generic container, in the form of an enum that holds exactly one value of any of the other
types.</p>
</td></tr></table><h2 id='constants' class='section-header'><a href="#constants">Constants</a></h2>
<table><tr class='module-item'><td><a class="constant" href="constant.ARRAY_SIGNATURE_CHAR.html" title='zvariant::ARRAY_SIGNATURE_CHAR constant'>ARRAY_SIGNATURE_CHAR</a></td><td class='docblock-short'><p>The prefix of ARRAY type signature, as a character. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.ARRAY_SIGNATURE_STR.html" title='zvariant::ARRAY_SIGNATURE_STR constant'>ARRAY_SIGNATURE_STR</a></td><td class='docblock-short'><p>The prefix of ARRAY type signature, as a string. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.DICT_ENTRY_SIG_END_CHAR.html" title='zvariant::DICT_ENTRY_SIG_END_CHAR constant'>DICT_ENTRY_SIG_END_CHAR</a></td><td class='docblock-short'><p>The closing character of DICT_ENTRY type signature. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.DICT_ENTRY_SIG_END_STR.html" title='zvariant::DICT_ENTRY_SIG_END_STR constant'>DICT_ENTRY_SIG_END_STR</a></td><td class='docblock-short'><p>The closing character of DICT_ENTRY type signature, as a string. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.DICT_ENTRY_SIG_START_CHAR.html" title='zvariant::DICT_ENTRY_SIG_START_CHAR constant'>DICT_ENTRY_SIG_START_CHAR</a></td><td class='docblock-short'><p>The opening character of DICT_ENTRY type signature. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.DICT_ENTRY_SIG_START_STR.html" title='zvariant::DICT_ENTRY_SIG_START_STR constant'>DICT_ENTRY_SIG_START_STR</a></td><td class='docblock-short'><p>The opening character of DICT_ENTRY type signature, as a string. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.STRUCT_SIG_END_CHAR.html" title='zvariant::STRUCT_SIG_END_CHAR constant'>STRUCT_SIG_END_CHAR</a></td><td class='docblock-short'><p>The closing character of STRUCT type signature. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.STRUCT_SIG_END_STR.html" title='zvariant::STRUCT_SIG_END_STR constant'>STRUCT_SIG_END_STR</a></td><td class='docblock-short'><p>The closing character of STRUCT type signature, as a string. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.STRUCT_SIG_START_CHAR.html" title='zvariant::STRUCT_SIG_START_CHAR constant'>STRUCT_SIG_START_CHAR</a></td><td class='docblock-short'><p>The opening character of STRUCT type signature. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.STRUCT_SIG_START_STR.html" title='zvariant::STRUCT_SIG_START_STR constant'>STRUCT_SIG_START_STR</a></td><td class='docblock-short'><p>The opening character of STRUCT type signature, as a string. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.VARIANT_SIGNATURE_CHAR.html" title='zvariant::VARIANT_SIGNATURE_CHAR constant'>VARIANT_SIGNATURE_CHAR</a></td><td class='docblock-short'><p>The VARIANT type signature. Provided for manual signature creation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.VARIANT_SIGNATURE_STR.html" title='zvariant::VARIANT_SIGNATURE_STR constant'>VARIANT_SIGNATURE_STR</a></td><td class='docblock-short'><p>The VARIANT type signature, as a string. Provided for manual signature creation.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.Basic.html" title='zvariant::Basic trait'>Basic</a></td><td class='docblock-short'><p>Trait for basic types.</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Type.html" title='zvariant::Type trait'>Type</a></td><td class='docblock-short'><p>Trait implemented by all serializable types.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.from_slice.html" title='zvariant::from_slice fn'>from_slice</a></td><td class='docblock-short'><p>Deserialize <code>T</code> from a given slice of bytes.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.from_slice_fds.html" title='zvariant::from_slice_fds fn'>from_slice_fds</a></td><td class='docblock-short'><p>Deserialize <code>T</code> from a given slice of bytes, containing file descriptor indices.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.from_slice_fds_for_signature.html" title='zvariant::from_slice_fds_for_signature fn'>from_slice_fds_for_signature</a></td><td class='docblock-short'><p>Deserialize <code>T</code> from a given slice of bytes containing file descriptor indices, with the given signature.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.from_slice_for_signature.html" title='zvariant::from_slice_for_signature fn'>from_slice_for_signature</a></td><td class='docblock-short'><p>Deserialize <code>T</code> from a given slice of bytes with the given signature.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.serialized_size.html" title='zvariant::serialized_size fn'>serialized_size</a></td><td class='docblock-short'><p>Calculate the serialized size of <code>T</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.serialized_size_fds.html" title='zvariant::serialized_size_fds fn'>serialized_size_fds</a></td><td class='docblock-short'><p>Calculate the serialized size of <code>T</code> that (potentially) contains FDs.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_bytes.html" title='zvariant::to_bytes fn'>to_bytes</a></td><td class='docblock-short'><p>Serialize <code>T</code> as a byte vector.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_bytes_fds.html" title='zvariant::to_bytes_fds fn'>to_bytes_fds</a></td><td class='docblock-short'><p>Serialize <code>T</code> that (potentially) contains FDs, as a byte vector.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_bytes_fds_for_signature.html" title='zvariant::to_bytes_fds_for_signature fn'>to_bytes_fds_for_signature</a></td><td class='docblock-short'><p>Serialize <code>T</code> that (potentially) contains FDs and has the given signature, to a new byte vector.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_bytes_for_signature.html" title='zvariant::to_bytes_for_signature fn'>to_bytes_for_signature</a></td><td class='docblock-short'><p>Serialize <code>T</code> that has the given signature, to a new byte vector.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_writer.html" title='zvariant::to_writer fn'>to_writer</a></td><td class='docblock-short'><p>Serialize <code>T</code> to the given <code>writer</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_writer_fds.html" title='zvariant::to_writer_fds fn'>to_writer_fds</a></td><td class='docblock-short'><p>Serialize <code>T</code> that (potentially) contains FDs, to the given <code>writer</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_writer_fds_for_signature.html" title='zvariant::to_writer_fds_for_signature fn'>to_writer_fds_for_signature</a></td><td class='docblock-short'><p>Serialize <code>T</code> that (potentially) contains FDs and has the given signature, to the given <code>writer</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_writer_for_signature.html" title='zvariant::to_writer_for_signature fn'>to_writer_for_signature</a></td><td class='docblock-short'><p>Serialize <code>T</code> that has the given signature, to the given <code>writer</code>.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Result.html" title='zvariant::Result type'>Result</a></td><td class='docblock-short'><p>Alias for a <code>Result</code> with the error type <code>zvariant::Error</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "zvariant";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>